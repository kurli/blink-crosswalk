void MeshBasicMaterial::initUniforms(UniformMap& um) {
    um = {
        { "diffuse", newUniform<'c'>(Color(0xeeeeee)) },
        { "opacity", newUniform<'f'>(1.0f) },
        { "map", newUniform<'t'>() },
        { "offsetRepeat", newUniform<'v4'>(Vector4(0.0f, 0.0f, 1.0f, 1.0f)) },
        { "lightMap", newUniform<'t'>() },
        { "specularMap", newUniform<'t'>() },
        { "envMap", newUniform<'t'>() },
        { "flipEnvMap", newUniform<'f'>(-1.0f) },
        { "useRefract", newUniform<'i'>(0) },
        { "reflectivity", newUniform<'f'>(1.0f) },
        { "refractionRatio", newUniform<'f'>(0.98f) },
        { "combine", newUniform<'i'>(0) },
        { "morphTargetInfluences", newUniform<'f'>(0.0f) },
        { "fogDensity", newUniform<'f'>(0.00025f) },
        { "fogNear", newUniform<'f'>(1.0f) },
        { "fogFar", newUniform<'f'>(2000.0f) },
        { "fogColor", newUniform<'c'>(Color(0xffffff)) },
        { "shadowMap", newUniform<'tv'>() },
        { "shadowMapSize", newUniform<'v2v'>() },
        { "shadowBias", newUniform<'fv1'>() },
        { "shadowDarkness", newUniform<'fv1'>() },
        { "shadowMatrix", newUniform<'m4v'>() },
    };
}

const std::string MeshBasicMaterial::kVertexShader = 
"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n"
"varying vec2 vUv;\n"
"uniform vec4 offsetRepeat;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"varying vec2 vUv2;\n"
"#endif\n"
"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n"
"varying vec3 vReflect;\n"
"uniform float refractionRatio;\n"
"uniform bool useRefract;\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"varying vec3 vColor;\n"
"#endif\n"
"#ifdef USE_MORPHTARGETS\n"
"#ifndef USE_MORPHNORMALS\n"
"uniform float morphTargetInfluences[ 8 ];\n"
"#else\n"
"uniform float morphTargetInfluences[ 4 ];\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"#ifdef BONE_TEXTURE\n"
"uniform sampler2D boneTexture;\n"
"uniform int boneTextureWidth;\n"
"uniform int boneTextureHeight;\n"
"mat4 getBoneMatrix( const in float i ) {\n"
"float j = i * 4.0;\n"
"float x = mod( j, float( boneTextureWidth ) );\n"
"float y = floor( j / float( boneTextureWidth ) );\n"
"float dx = 1.0 / float( boneTextureWidth );\n"
"float dy = 1.0 / float( boneTextureHeight );\n"
"y = dy * ( y + 0.5 );\n"
"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n"
"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n"
"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n"
"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n"
"mat4 bone = mat4( v1, v2, v3, v4 );\n"
"return bone;\n"
"}\n"
"#else\n"
"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n"
"mat4 getBoneMatrix( const in float i ) {\n"
"mat4 bone = boneGlobalMatrices[ int(i) ];\n"
"return bone;\n"
"}\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"varying vec4 vShadowCoord[ MAX_SHADOWS ];\n"
"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n"
"#endif\n"
"void main() {\n"
"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n"
"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"vUv2 = uv2;\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"#ifdef GAMMA_INPUT\n"
"vColor = color * color;\n"
"#else\n"
"vColor = color;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"mat4 boneMatX = getBoneMatrix( skinIndex.x );\n"
"mat4 boneMatY = getBoneMatrix( skinIndex.y );\n"
"#endif\n"
"#ifdef USE_ENVMAP\n"
"#ifdef USE_MORPHNORMALS\n"
"vec3 morphedNormal = vec3( 0.0 );\n"
"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n"
"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n"
"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n"
"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n"
"morphedNormal += normal;\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"mat4 skinMatrix = skinWeight.x * boneMatX;\n"
"skinMatrix 	+= skinWeight.y * boneMatY;\n"
"#ifdef USE_MORPHNORMALS\n"
"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n"
"#else\n"
"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n"
"#endif\n"
"#endif\n"
"vec3 objectNormal;\n"
"#ifdef USE_SKINNING\n"
"objectNormal = skinnedNormal.xyz;\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n"
"objectNormal = morphedNormal;\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n"
"objectNormal = normal;\n"
"#endif\n"
"#ifdef FLIP_SIDED\n"
"objectNormal = -objectNormal;\n"
"#endif\n"
"vec3 transformedNormal = normalMatrix * objectNormal;\n"
"#endif\n"
"#ifdef USE_MORPHTARGETS\n"
"vec3 morphed = vec3( 0.0 );\n"
"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n"
"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n"
"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n"
"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n"
"#ifndef USE_MORPHNORMALS\n"
"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n"
"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n"
"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n"
"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n"
"#endif\n"
"morphed += position;\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"#ifdef USE_MORPHTARGETS\n"
"vec4 skinVertex = vec4( morphed, 1.0 );\n"
"#else\n"
"vec4 skinVertex = vec4( position, 1.0 );\n"
"#endif\n"
"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n"
"skinned 	  += boneMatY * skinVertex * skinWeight.y;\n"
"#endif\n"
"vec4 mvPosition;\n"
"#ifdef USE_SKINNING\n"
"mvPosition = modelViewMatrix * skinned;\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n"
"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n"
"mvPosition = modelViewMatrix * vec4( position, 1.0 );\n"
"#endif\n"
"gl_Position = projectionMatrix * mvPosition;\n"
"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n"
"#ifdef USE_SKINNING\n"
"vec4 worldPosition = modelMatrix * skinned;\n"
"#endif\n"
"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n"
"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n"
"#endif\n"
"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n"
"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n"
"#endif\n"
"#endif\n"
"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n"
"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n"
"worldNormal = normalize( worldNormal );\n"
"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n"
"if ( useRefract ) {\n"
"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n"
"} else {\n"
"vReflect = reflect( cameraToVertex, worldNormal );\n"
"}\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n"
"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n"
"}\n"
"#endif\n"
"}\n";

const std::string MeshBasicMaterial::kFragmentShader = 
"uniform vec3 diffuse;\n"
"uniform float opacity;\n"
"#ifdef USE_COLOR\n"
"varying vec3 vColor;\n"
"#endif\n"
"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n"
"varying vec2 vUv;\n"
"#endif\n"
"#ifdef USE_MAP\n"
"uniform sampler2D map;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"varying vec2 vUv2;\n"
"uniform sampler2D lightMap;\n"
"#endif\n"
"#ifdef USE_ENVMAP\n"
"uniform float reflectivity;\n"
"uniform samplerCube envMap;\n"
"uniform float flipEnvMap;\n"
"uniform int combine;\n"
"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n"
"uniform bool useRefract;\n"
"uniform float refractionRatio;\n"
"#else\n"
"varying vec3 vReflect;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_FOG\n"
"uniform vec3 fogColor;\n"
"#ifdef FOG_EXP2\n"
"uniform float fogDensity;\n"
"#else\n"
"uniform float fogNear;\n"
"uniform float fogFar;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"uniform sampler2D shadowMap[ MAX_SHADOWS ];\n"
"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n"
"uniform float shadowDarkness[ MAX_SHADOWS ];\n"
"uniform float shadowBias[ MAX_SHADOWS ];\n"
"varying vec4 vShadowCoord[ MAX_SHADOWS ];\n"
"float unpackDepth( const in vec4 rgba_depth ) {\n"
"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n"
"float depth = dot( rgba_depth, bit_shift );\n"
"return depth;\n"
"}\n"
"#endif\n"
"#ifdef USE_SPECULARMAP\n"
"uniform sampler2D specularMap;\n"
"#endif\n"
"void main() {\n"
"gl_FragColor = vec4( diffuse, opacity );\n"
"#ifdef USE_MAP\n"
"vec4 texelColor = texture2D( map, vUv );\n"
"#ifdef GAMMA_INPUT\n"
"texelColor.xyz *= texelColor.xyz;\n"
"#endif\n"
"gl_FragColor = gl_FragColor * texelColor;\n"
"#endif\n"
"#ifdef ALPHATEST\n"
"if ( gl_FragColor.a < ALPHATEST ) discard;\n"
"#endif\n"
"float specularStrength;\n"
"#ifdef USE_SPECULARMAP\n"
"vec4 texelSpecular = texture2D( specularMap, vUv );\n"
"specularStrength = texelSpecular.r;\n"
"#else\n"
"specularStrength = 1.0;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\n"
"#endif\n"
"#ifdef USE_ENVMAP\n"
"vec3 reflectVec;\n"
"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n"
"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n"
"if ( useRefract ) {\n"
"reflectVec = refract( cameraToVertex, normal, refractionRatio );\n"
"} else { \n"
"reflectVec = reflect( cameraToVertex, normal );\n"
"}\n"
"#else\n"
"reflectVec = vReflect;\n"
"#endif\n"
"#ifdef DOUBLE_SIDED\n"
"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n"
"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n"
"#else\n"
"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n"
"#endif\n"
"#ifdef GAMMA_INPUT\n"
"cubeColor.xyz *= cubeColor.xyz;\n"
"#endif\n"
"if ( combine == 1 ) {\n"
"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n"
"} else if ( combine == 2 ) {\n"
"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n"
"} else {\n"
"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n"
"}\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"#ifdef SHADOWMAP_DEBUG\n"
"vec3 frustumColors[3];\n"
"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n"
"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n"
"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n"
"#endif\n"
"#ifdef SHADOWMAP_CASCADE\n"
"int inFrustumCount = 0;\n"
"#endif\n"
"float fDepth;\n"
"vec3 shadowColor = vec3( 1.0 );\n"
"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n"
"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n"
"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n"
"bool inFrustum = all( inFrustumVec );\n"
"#ifdef SHADOWMAP_CASCADE\n"
"inFrustumCount += int( inFrustum );\n"
"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n"
"#else\n"
"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n"
"#endif\n"
"bool frustumTest = all( frustumTestVec );\n"
"if ( frustumTest ) {\n"
"shadowCoord.z += shadowBias[ i ];\n"
"#if defined( SHADOWMAP_TYPE_PCF )\n"
"float shadow = 0.0;\n"
"const float shadowDelta = 1.0 / 9.0;\n"
"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n"
"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n"
"float dx0 = -1.25 * xPixelOffset;\n"
"float dy0 = -1.25 * yPixelOffset;\n"
"float dx1 = 1.25 * xPixelOffset;\n"
"float dy1 = 1.25 * yPixelOffset;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n"
"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n"
"float shadow = 0.0;\n"
"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n"
"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n"
"float dx0 = -1.0 * xPixelOffset;\n"
"float dy0 = -1.0 * yPixelOffset;\n"
"float dx1 = 1.0 * xPixelOffset;\n"
"float dy1 = 1.0 * yPixelOffset;\n"
"mat3 shadowKernel;\n"
"mat3 depthKernel;\n"
"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n"
"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n"
"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n"
"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n"
"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n"
"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n"
"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n"
"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n"
"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n"
"vec3 shadowZ = vec3( shadowCoord.z );\n"
"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n"
"shadowKernel[0] *= vec3(0.25);\n"
"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n"
"shadowKernel[1] *= vec3(0.25);\n"
"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n"
"shadowKernel[2] *= vec3(0.25);\n"
"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n"
"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n"
"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n"
"vec4 shadowValues;\n"
"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n"
"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n"
"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n"
"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n"
"shadow = dot( shadowValues, vec4( 1.0 ) );\n"
"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n"
"#else\n"
"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n"
"float fDepth = unpackDepth( rgbaDepth );\n"
"if ( fDepth < shadowCoord.z )\n"
"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n"
"#endif\n"
"}\n"
"#ifdef SHADOWMAP_DEBUG\n"
"#ifdef SHADOWMAP_CASCADE\n"
"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n"
"#else\n"
"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n"
"#endif\n"
"#endif\n"
"}\n"
"#ifdef GAMMA_OUTPUT\n"
"shadowColor *= shadowColor;\n"
"#endif\n"
"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n"
"#endif\n"
"#ifdef GAMMA_OUTPUT\n"
"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n"
"#endif\n"
"#ifdef USE_FOG\n"
"float depth = gl_FragCoord.z / gl_FragCoord.w;\n"
"#ifdef FOG_EXP2\n"
"const float LOG2 = 1.442695;\n"
"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n"
"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n"
"#else\n"
"float fogFactor = smoothstep( fogNear, fogFar, depth );\n"
"#endif\n"
"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n"
"#endif\n"
"}\n";