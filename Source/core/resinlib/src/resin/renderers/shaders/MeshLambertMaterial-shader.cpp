void MeshLambertMaterial::initUniforms(UniformMap& um) {
    um = {
        { "diffuse", newUniform<'c'>(Color(0xeeeeee)) },
        { "opacity", newUniform<'f'>(1.0f) },
        { "map", newUniform<'t'>() },
        { "offsetRepeat", newUniform<'v4'>(Vector4(0.0f, 0.0f, 1.0f, 1.0f)) },
        { "lightMap", newUniform<'t'>() },
        { "specularMap", newUniform<'t'>() },
        { "envMap", newUniform<'t'>() },
        { "flipEnvMap", newUniform<'f'>(-1.0f) },
        { "useRefract", newUniform<'i'>(0) },
        { "reflectivity", newUniform<'f'>(1.0f) },
        { "refractionRatio", newUniform<'f'>(0.98f) },
        { "combine", newUniform<'i'>(0) },
        { "morphTargetInfluences", newUniform<'f'>(0.0f) },
        { "fogDensity", newUniform<'f'>(0.00025f) },
        { "fogNear", newUniform<'f'>(1.0f) },
        { "fogFar", newUniform<'f'>(2000.0f) },
        { "fogColor", newUniform<'c'>(Color(0xffffff)) },
        { "ambientLightColor", newUniform<'fv'>() },
        { "directionalLightDirection", newUniform<'fv'>() },
        { "directionalLightColor", newUniform<'fv'>() },
        { "hemisphereLightDirection", newUniform<'fv'>() },
        { "hemisphereLightSkyColor", newUniform<'fv'>() },
        { "hemisphereLightGroundColor", newUniform<'fv'>() },
        { "pointLightColor", newUniform<'fv'>() },
        { "pointLightPosition", newUniform<'fv'>() },
        { "pointLightDistance", newUniform<'fv1'>() },
        { "spotLightColor", newUniform<'fv'>() },
        { "spotLightPosition", newUniform<'fv'>() },
        { "spotLightDirection", newUniform<'fv'>() },
        { "spotLightDistance", newUniform<'fv1'>() },
        { "spotLightAngleCos", newUniform<'fv1'>() },
        { "spotLightExponent", newUniform<'fv1'>() },
        { "shadowMap", newUniform<'tv'>() },
        { "shadowMapSize", newUniform<'v2v'>() },
        { "shadowBias", newUniform<'fv1'>() },
        { "shadowDarkness", newUniform<'fv1'>() },
        { "shadowMatrix", newUniform<'m4v'>() },
        { "ambient", newUniform<'c'>(Color(0xffffff)) },
        { "emissive", newUniform<'c'>(Color(0x000000)) },
        { "wrapRGB", newUniform<'v3'>(Vector3(1.0f, 1.0f, 1.0f)) },
    };
}

const std::string MeshLambertMaterial::kVertexShader = 
"#define LAMBERT\n"
"varying vec3 vLightFront;\n"
"#ifdef DOUBLE_SIDED\n"
"varying vec3 vLightBack;\n"
"#endif\n"
"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n"
"varying vec2 vUv;\n"
"uniform vec4 offsetRepeat;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"varying vec2 vUv2;\n"
"#endif\n"
"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n"
"varying vec3 vReflect;\n"
"uniform float refractionRatio;\n"
"uniform bool useRefract;\n"
"#endif\n"
"uniform vec3 ambient;\n"
"uniform vec3 diffuse;\n"
"uniform vec3 emissive;\n"
"uniform vec3 ambientLightColor;\n"
"#if MAX_DIR_LIGHTS > 0\n"
"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n"
"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n"
"#endif\n"
"#if MAX_HEMI_LIGHTS > 0\n"
"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n"
"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n"
"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n"
"#endif\n"
"#if MAX_POINT_LIGHTS > 0\n"
"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n"
"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n"
"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n"
"#endif\n"
"#if MAX_SPOT_LIGHTS > 0\n"
"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n"
"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n"
"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n"
"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n"
"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n"
"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n"
"#endif\n"
"#ifdef WRAP_AROUND\n"
"uniform vec3 wrapRGB;\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"varying vec3 vColor;\n"
"#endif\n"
"#ifdef USE_MORPHTARGETS\n"
"#ifndef USE_MORPHNORMALS\n"
"uniform float morphTargetInfluences[ 8 ];\n"
"#else\n"
"uniform float morphTargetInfluences[ 4 ];\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"#ifdef BONE_TEXTURE\n"
"uniform sampler2D boneTexture;\n"
"uniform int boneTextureWidth;\n"
"uniform int boneTextureHeight;\n"
"mat4 getBoneMatrix( const in float i ) {\n"
"float j = i * 4.0;\n"
"float x = mod( j, float( boneTextureWidth ) );\n"
"float y = floor( j / float( boneTextureWidth ) );\n"
"float dx = 1.0 / float( boneTextureWidth );\n"
"float dy = 1.0 / float( boneTextureHeight );\n"
"y = dy * ( y + 0.5 );\n"
"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n"
"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n"
"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n"
"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n"
"mat4 bone = mat4( v1, v2, v3, v4 );\n"
"return bone;\n"
"}\n"
"#else\n"
"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n"
"mat4 getBoneMatrix( const in float i ) {\n"
"mat4 bone = boneGlobalMatrices[ int(i) ];\n"
"return bone;\n"
"}\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"varying vec4 vShadowCoord[ MAX_SHADOWS ];\n"
"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n"
"#endif\n"
"void main() {\n"
"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n"
"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"vUv2 = uv2;\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"#ifdef GAMMA_INPUT\n"
"vColor = color * color;\n"
"#else\n"
"vColor = color;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_MORPHNORMALS\n"
"vec3 morphedNormal = vec3( 0.0 );\n"
"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n"
"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n"
"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n"
"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n"
"morphedNormal += normal;\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"mat4 boneMatX = getBoneMatrix( skinIndex.x );\n"
"mat4 boneMatY = getBoneMatrix( skinIndex.y );\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"mat4 skinMatrix = skinWeight.x * boneMatX;\n"
"skinMatrix 	+= skinWeight.y * boneMatY;\n"
"#ifdef USE_MORPHNORMALS\n"
"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n"
"#else\n"
"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n"
"#endif\n"
"#endif\n"
"vec3 objectNormal;\n"
"#ifdef USE_SKINNING\n"
"objectNormal = skinnedNormal.xyz;\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n"
"objectNormal = morphedNormal;\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n"
"objectNormal = normal;\n"
"#endif\n"
"#ifdef FLIP_SIDED\n"
"objectNormal = -objectNormal;\n"
"#endif\n"
"vec3 transformedNormal = normalMatrix * objectNormal;\n"
"#ifdef USE_MORPHTARGETS\n"
"vec3 morphed = vec3( 0.0 );\n"
"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n"
"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n"
"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n"
"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n"
"#ifndef USE_MORPHNORMALS\n"
"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n"
"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n"
"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n"
"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n"
"#endif\n"
"morphed += position;\n"
"#endif\n"
"#ifdef USE_SKINNING\n"
"#ifdef USE_MORPHTARGETS\n"
"vec4 skinVertex = vec4( morphed, 1.0 );\n"
"#else\n"
"vec4 skinVertex = vec4( position, 1.0 );\n"
"#endif\n"
"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n"
"skinned 	  += boneMatY * skinVertex * skinWeight.y;\n"
"#endif\n"
"vec4 mvPosition;\n"
"#ifdef USE_SKINNING\n"
"mvPosition = modelViewMatrix * skinned;\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n"
"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n"
"#endif\n"
"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n"
"mvPosition = modelViewMatrix * vec4( position, 1.0 );\n"
"#endif\n"
"gl_Position = projectionMatrix * mvPosition;\n"
"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n"
"#ifdef USE_SKINNING\n"
"vec4 worldPosition = modelMatrix * skinned;\n"
"#endif\n"
"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n"
"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n"
"#endif\n"
"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n"
"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n"
"#endif\n"
"#endif\n"
"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n"
"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n"
"worldNormal = normalize( worldNormal );\n"
"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n"
"if ( useRefract ) {\n"
"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n"
"} else {\n"
"vReflect = reflect( cameraToVertex, worldNormal );\n"
"}\n"
"#endif\n"
"vLightFront = vec3( 0.0 );\n"
"#ifdef DOUBLE_SIDED\n"
"vLightBack = vec3( 0.0 );\n"
"#endif\n"
"transformedNormal = normalize( transformedNormal );\n"
"#if MAX_DIR_LIGHTS > 0\n"
"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n"
"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n"
"vec3 dirVector = normalize( lDirection.xyz );\n"
"float dotProduct = dot( transformedNormal, dirVector );\n"
"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n"
"#ifdef DOUBLE_SIDED\n"
"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n"
"#ifdef WRAP_AROUND\n"
"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n"
"#endif\n"
"#endif\n"
"#ifdef WRAP_AROUND\n"
"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n"
"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n"
"#ifdef DOUBLE_SIDED\n"
"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n"
"#endif\n"
"#endif\n"
"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n"
"#ifdef DOUBLE_SIDED\n"
"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n"
"#endif\n"
"}\n"
"#endif\n"
"#if MAX_POINT_LIGHTS > 0\n"
"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n"
"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n"
"vec3 lVector = lPosition.xyz - mvPosition.xyz;\n"
"float lDistance = 1.0;\n"
"if ( pointLightDistance[ i ] > 0.0 )\n"
"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n"
"lVector = normalize( lVector );\n"
"float dotProduct = dot( transformedNormal, lVector );\n"
"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n"
"#ifdef DOUBLE_SIDED\n"
"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n"
"#ifdef WRAP_AROUND\n"
"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n"
"#endif\n"
"#endif\n"
"#ifdef WRAP_AROUND\n"
"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n"
"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n"
"#ifdef DOUBLE_SIDED\n"
"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n"
"#endif\n"
"#endif\n"
"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n"
"#ifdef DOUBLE_SIDED\n"
"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n"
"#endif\n"
"}\n"
"#endif\n"
"#if MAX_SPOT_LIGHTS > 0\n"
"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n"
"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n"
"vec3 lVector = lPosition.xyz - mvPosition.xyz;\n"
"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n"
"if ( spotEffect > spotLightAngleCos[ i ] ) {\n"
"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n"
"float lDistance = 1.0;\n"
"if ( spotLightDistance[ i ] > 0.0 )\n"
"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n"
"lVector = normalize( lVector );\n"
"float dotProduct = dot( transformedNormal, lVector );\n"
"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n"
"#ifdef DOUBLE_SIDED\n"
"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n"
"#ifdef WRAP_AROUND\n"
"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n"
"#endif\n"
"#endif\n"
"#ifdef WRAP_AROUND\n"
"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n"
"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n"
"#ifdef DOUBLE_SIDED\n"
"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n"
"#endif\n"
"#endif\n"
"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n"
"#ifdef DOUBLE_SIDED\n"
"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n"
"#endif\n"
"}\n"
"}\n"
"#endif\n"
"#if MAX_HEMI_LIGHTS > 0\n"
"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n"
"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n"
"vec3 lVector = normalize( lDirection.xyz );\n"
"float dotProduct = dot( transformedNormal, lVector );\n"
"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n"
"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n"
"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n"
"#ifdef DOUBLE_SIDED\n"
"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n"
"#endif\n"
"}\n"
"#endif\n"
"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n"
"#ifdef DOUBLE_SIDED\n"
"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n"
"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n"
"}\n"
"#endif\n"
"}\n";

const std::string MeshLambertMaterial::kFragmentShader = 
"uniform float opacity;\n"
"varying vec3 vLightFront;\n"
"#ifdef DOUBLE_SIDED\n"
"varying vec3 vLightBack;\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"varying vec3 vColor;\n"
"#endif\n"
"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\n"
"varying vec2 vUv;\n"
"#endif\n"
"#ifdef USE_MAP\n"
"uniform sampler2D map;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"varying vec2 vUv2;\n"
"uniform sampler2D lightMap;\n"
"#endif\n"
"#ifdef USE_ENVMAP\n"
"uniform float reflectivity;\n"
"uniform samplerCube envMap;\n"
"uniform float flipEnvMap;\n"
"uniform int combine;\n"
"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n"
"uniform bool useRefract;\n"
"uniform float refractionRatio;\n"
"#else\n"
"varying vec3 vReflect;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_FOG\n"
"uniform vec3 fogColor;\n"
"#ifdef FOG_EXP2\n"
"uniform float fogDensity;\n"
"#else\n"
"uniform float fogNear;\n"
"uniform float fogFar;\n"
"#endif\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"uniform sampler2D shadowMap[ MAX_SHADOWS ];\n"
"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n"
"uniform float shadowDarkness[ MAX_SHADOWS ];\n"
"uniform float shadowBias[ MAX_SHADOWS ];\n"
"varying vec4 vShadowCoord[ MAX_SHADOWS ];\n"
"float unpackDepth( const in vec4 rgba_depth ) {\n"
"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n"
"float depth = dot( rgba_depth, bit_shift );\n"
"return depth;\n"
"}\n"
"#endif\n"
"#ifdef USE_SPECULARMAP\n"
"uniform sampler2D specularMap;\n"
"#endif\n"
"void main() {\n"
"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\n"
"#ifdef USE_MAP\n"
"vec4 texelColor = texture2D( map, vUv );\n"
"#ifdef GAMMA_INPUT\n"
"texelColor.xyz *= texelColor.xyz;\n"
"#endif\n"
"gl_FragColor = gl_FragColor * texelColor;\n"
"#endif\n"
"#ifdef ALPHATEST\n"
"if ( gl_FragColor.a < ALPHATEST ) discard;\n"
"#endif\n"
"float specularStrength;\n"
"#ifdef USE_SPECULARMAP\n"
"vec4 texelSpecular = texture2D( specularMap, vUv );\n"
"specularStrength = texelSpecular.r;\n"
"#else\n"
"specularStrength = 1.0;\n"
"#endif\n"
"#ifdef DOUBLE_SIDED\n"
"if ( gl_FrontFacing )\n"
"gl_FragColor.xyz *= vLightFront;\n"
"else\n"
"gl_FragColor.xyz *= vLightBack;\n"
"#else\n"
"gl_FragColor.xyz *= vLightFront;\n"
"#endif\n"
"#ifdef USE_LIGHTMAP\n"
"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n"
"#endif\n"
"#ifdef USE_COLOR\n"
"gl_FragColor = gl_FragColor * vec4( vColor, opacity );\n"
"#endif\n"
"#ifdef USE_ENVMAP\n"
"vec3 reflectVec;\n"
"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n"
"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n"
"if ( useRefract ) {\n"
"reflectVec = refract( cameraToVertex, normal, refractionRatio );\n"
"} else { \n"
"reflectVec = reflect( cameraToVertex, normal );\n"
"}\n"
"#else\n"
"reflectVec = vReflect;\n"
"#endif\n"
"#ifdef DOUBLE_SIDED\n"
"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n"
"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n"
"#else\n"
"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n"
"#endif\n"
"#ifdef GAMMA_INPUT\n"
"cubeColor.xyz *= cubeColor.xyz;\n"
"#endif\n"
"if ( combine == 1 ) {\n"
"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n"
"} else if ( combine == 2 ) {\n"
"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n"
"} else {\n"
"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n"
"}\n"
"#endif\n"
"#ifdef USE_SHADOWMAP\n"
"#ifdef SHADOWMAP_DEBUG\n"
"vec3 frustumColors[3];\n"
"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n"
"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n"
"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n"
"#endif\n"
"#ifdef SHADOWMAP_CASCADE\n"
"int inFrustumCount = 0;\n"
"#endif\n"
"float fDepth;\n"
"vec3 shadowColor = vec3( 1.0 );\n"
"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n"
"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n"
"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n"
"bool inFrustum = all( inFrustumVec );\n"
"#ifdef SHADOWMAP_CASCADE\n"
"inFrustumCount += int( inFrustum );\n"
"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n"
"#else\n"
"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n"
"#endif\n"
"bool frustumTest = all( frustumTestVec );\n"
"if ( frustumTest ) {\n"
"shadowCoord.z += shadowBias[ i ];\n"
"#if defined( SHADOWMAP_TYPE_PCF )\n"
"float shadow = 0.0;\n"
"const float shadowDelta = 1.0 / 9.0;\n"
"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n"
"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n"
"float dx0 = -1.25 * xPixelOffset;\n"
"float dy0 = -1.25 * yPixelOffset;\n"
"float dx1 = 1.25 * xPixelOffset;\n"
"float dy1 = 1.25 * yPixelOffset;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n"
"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n"
"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n"
"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n"
"float shadow = 0.0;\n"
"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n"
"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n"
"float dx0 = -1.0 * xPixelOffset;\n"
"float dy0 = -1.0 * yPixelOffset;\n"
"float dx1 = 1.0 * xPixelOffset;\n"
"float dy1 = 1.0 * yPixelOffset;\n"
"mat3 shadowKernel;\n"
"mat3 depthKernel;\n"
"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n"
"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n"
"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n"
"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n"
"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n"
"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n"
"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n"
"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n"
"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n"
"vec3 shadowZ = vec3( shadowCoord.z );\n"
"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n"
"shadowKernel[0] *= vec3(0.25);\n"
"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n"
"shadowKernel[1] *= vec3(0.25);\n"
"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n"
"shadowKernel[2] *= vec3(0.25);\n"
"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n"
"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n"
"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n"
"vec4 shadowValues;\n"
"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n"
"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n"
"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n"
"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n"
"shadow = dot( shadowValues, vec4( 1.0 ) );\n"
"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n"
"#else\n"
"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n"
"float fDepth = unpackDepth( rgbaDepth );\n"
"if ( fDepth < shadowCoord.z )\n"
"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n"
"#endif\n"
"}\n"
"#ifdef SHADOWMAP_DEBUG\n"
"#ifdef SHADOWMAP_CASCADE\n"
"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n"
"#else\n"
"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n"
"#endif\n"
"#endif\n"
"}\n"
"#ifdef GAMMA_OUTPUT\n"
"shadowColor *= shadowColor;\n"
"#endif\n"
"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n"
"#endif\n"
"#ifdef GAMMA_OUTPUT\n"
"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n"
"#endif\n"
"#ifdef USE_FOG\n"
"float depth = gl_FragCoord.z / gl_FragCoord.w;\n"
"#ifdef FOG_EXP2\n"
"const float LOG2 = 1.442695;\n"
"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n"
"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n"
"#else\n"
"float fogFactor = smoothstep( fogNear, fogFar, depth );\n"
"#endif\n"
"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n"
"#endif\n"
"}\n";